<!DOCTYPE html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <!-- three.js library -->
    <script src='package/three.min.js'></script>
    <script src="package/stats.min.js"></script>
    <!-- ar.js -->
    <script src="package/ar.js"></script>

    <script>THREEx.ArToolkitContext.baseURL = 'https://cdn.rawgit.com/jeromeetienne/AR.js/master/three.js/examples/'</script>
</head>

<body style='margin : 0px; overflow: hidden; font-family: Monospace;'><script>
    //////////////////////////////////////////////////////////////////////////////////
    //      Init
    //////////////////////////////////////////////////////////////////////////////////
    // init renderer
    var renderer    = new THREE.WebGLRenderer({
        // antialias    : true,
        alpha: true
    });
    renderer.setClearColor(new THREE.Color('lightgrey'), 0)
    // renderer.setPixelRatio( 1/2 );
    renderer.setSize( window.innerWidth, window.innerHeight );
    renderer.domElement.style.position = 'absolute'
    renderer.domElement.style.top = '0px'
    renderer.domElement.style.left = '0px'
    document.body.appendChild( renderer.domElement );
    renderer.domElement.addEventListener('touchstart', (e) => {
        // console.log(2222)

        const points = screenToWorldVector(e.touches[0].clientX, e.touches[0].clientY)
        // console.log(points, 222)
        const geometry = new THREE.BoxGeometry( 0.1, 0.1, 0.1 );
		const material = new THREE.MeshBasicMaterial( {color: 0xff0000} );
		const cube = new THREE.Mesh( geometry, material );
        // console.log(points)
        cube.position.set(points.x, points.y, 0.5)


        // const div = document.createElement("div");
        // div.style.height = "36px";
        // div.innerHTML = `${points.x}, ${points.y}, ${points.z}, ${window.innerWidth}, ${window.innerHeight}`
        // document.body.appendChild(div);
        console.log(arToolkitContext.getProjectionMatrix(), camera.matrixWorld)
        console.log(arToolkitContext.getProjectionMatrix().invert(), 222)

		markerRoot.add(cube);
        markerRoot.visible = true;
        let ray = new THREE.Raycaster()
        ray.set(points, new THREE.Vector3(0, 1, 0))
        const r1 = ray.intersectObjects(scene.children, true);
        console.log(r1)
    })

    function screenToWorldVector (evX, evY) {
        const width = window.innerWidth;
        const height = window.innerHeight;
        // console.log(camera)
        const x = evX;
        const y = evY;
        const x1 = (x / width) * 2 - 1;
        const y1 = -(y / height) * 2 + 1;
        const stdVector = new THREE.Vector3(x1, y1, 0.5);
        const worldVector = stdVector.unproject(camera);
        return worldVector;
    };
    // array of functions for the rendering loop
    var onRenderFcts= [];
    // init scene and camera
    var scene   = new THREE.Scene();
    //////////////////////////////////////////////////////////////////////////////////
    //      Initialize a basic camera
    //////////////////////////////////////////////////////////////////////////////////
    // Create a camera
    var camera = new THREE.Camera();
    // const camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1000 );
    scene.add(camera);

    ////////////////////////////////////////////////////////////////////////////////
    //          handle arToolkitSource
    ////////////////////////////////////////////////////////////////////////////////
    var arToolkitSource = new THREEx.ArToolkitSource({
        // to read from the webcam
        sourceType : 'webcam',
        // to read from an image
        // sourceType : 'image',
        // sourceUrl : THREEx.ArToolkitContext.baseURL + '../data/images/img.jpg',
        // to read from a video
        // sourceType : 'video',
        // sourceUrl : THREEx.ArToolkitContext.baseURL + '../data/videos/headtracking.mp4',
    })
    arToolkitSource.init(function onReady(){
        onResize()
    })
    // handle resize
    window.addEventListener('resize', function(){
        onResize()
    })
    function onResize(){
        arToolkitSource.onResizeElement()
        arToolkitSource.copyElementSizeTo(renderer.domElement)
        if( arToolkitContext.arController !== null ){
            arToolkitSource.copyElementSizeTo(arToolkitContext.arController.canvas)
        }
    }
    ////////////////////////////////////////////////////////////////////////////////
    //          initialize arToolkitContext
    ////////////////////////////////////////////////////////////////////////////////
    // create atToolkitContext
    var arToolkitContext = new THREEx.ArToolkitContext({
        cameraParametersUrl: 'camera_para.dat',
        detectionMode: 'mono',
        // maxDetectionRate: 30,
        // canvasWidth: 80*3,
        // canvasHeight: 60*3,
    })
    // initialize it
    arToolkitContext.init(function onCompleted(){
        // copy projection matrix to camera
        camera.projectionMatrix.copy( arToolkitContext.getProjectionMatrix() );
    })
    // update artoolkit on every frame
    onRenderFcts.push(function(){
        if( arToolkitSource.ready === false )   return
        console.log(arToolkitSource.domElement)
        // const div = document.createElement("div");
        // div.style.marginBottom = "16px";
        // div.innerHTML = JSON.stringify(arToolkitContext.getMatrixWorld())
        // document.body.appendChild(div);

        // const div2 = document.createElement("div");
        // div2.style.marginBottom = "16px";
        // div2.innerHTML = THREEx.ArToolkitContext.baseURL
        // document.body.appendChild(div2);
        
        arToolkitContext.update( arToolkitSource.domElement )
    })
    ////////////////////////////////////////////////////////////////////////////////
    //          Create a ArMarkerControls
    ////////////////////////////////////////////////////////////////////////////////
    var markerRoot = new THREE.Group
    scene.add(markerRoot)
    //HERE we define the marker... specify here your .patt file
    var artoolkitMarker = new THREEx.ArMarkerControls(arToolkitContext, markerRoot, {
        type : 'pattern',
        patternUrl : 'jgw.patt'
    })
    // build a smoothedControls
    var smoothedRoot = new THREE.Group()
    scene.add(smoothedRoot)
    var smoothedControls = new THREEx.ArSmoothedControls(smoothedRoot, {
        lerpPosition: 0.4,
        lerpQuaternion: 0.3,
        lerpScale: 1,
    })
    onRenderFcts.push(function(delta){
        smoothedControls.update(markerRoot)
    })
    //////////////////////////////////////////////////////////////////////////////////
    //      add an object in the scene
    //////////////////////////////////////////////////////////////////////////////////
    var arWorldRoot = smoothedRoot
    // add a torus knot
    var geometry    = new THREE.BoxGeometry(1,1,1);
    var material    = new THREE.MeshNormalMaterial({
        transparent : true,
        opacity: 0.5,
        side: THREE.DoubleSide
    });
    var mesh    = new THREE.Mesh( geometry, material );
    mesh.position.y = geometry.parameters.height/2
    arWorldRoot.add( mesh );
    var geometry    = new THREE.TorusKnotGeometry(0.3,0.1,64,16);
    var material    = new THREE.MeshNormalMaterial();
    var mesh    = new THREE.Mesh( geometry, material );
    mesh.position.y = 0.5
    arWorldRoot.add( mesh );
    onRenderFcts.push(function(){
        mesh.rotation.x += 0.1
    })
    //////////////////////////////////////////////////////////////////////////////////
    //      render the whole thing on the page
    //////////////////////////////////////////////////////////////////////////////////
    var stats = new Stats();
    document.body.appendChild( stats.dom );
    // render the scene
    onRenderFcts.push(function(){
        renderer.render( scene, camera );
        stats.update();
    })
    // run the rendering loop
    var lastTimeMsec= null
    requestAnimationFrame(function animate(nowMsec){
        // keep looping
        requestAnimationFrame( animate );
        // measure time
        lastTimeMsec    = lastTimeMsec || nowMsec-1000/60
        var deltaMsec   = Math.min(200, nowMsec - lastTimeMsec)
        lastTimeMsec    = nowMsec
        // call each update function
        onRenderFcts.forEach(function(onRenderFct){
            onRenderFct(deltaMsec/1000, nowMsec/1000)
        })
    })
</script></body>