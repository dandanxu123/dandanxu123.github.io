<!DOCTYPE html>
<meta
  name="viewport"
  content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
/>
<!-- three.js library -->
<script src="three.min.js"></script>
<!-- ar.js -->
<script src="ar.js"></script>
<script>
  THREEx.ArToolkitContext.baseURL = "./";
</script>

<body style="margin: 0px; overflow: hidden; font-family: Monospace">
  <script>
    const matrixWorld = new THREE.Matrix4();
    // init renderer
    var renderer = new THREE.WebGLRenderer({
      antialias: true,
      alpha: true,
    });
    renderer.setClearColor(new THREE.Color("lightgrey"), 0);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.domElement.style.position = "absolute";
    renderer.domElement.style.top = "0px";
    renderer.domElement.style.left = "0px";
    document.body.appendChild(renderer.domElement);
    renderer.domElement.addEventListener("touchstart", (e) => {
      // const m = new THREE.Matrix4()
      // m.getInverse(camera.projectionMatrix)
      // camera.projectionMatrixInverse.copy(m)
      // const points = screenToWorldVector(
      //   e.touches[0].clientX,
      //   e.touches[0].clientY
      // );
      // console.log(camera, '===camera')
      // console.log(arToolkitContext, '===Context')
      // console.log(arToolkitSource, '===Source')
      // console.log(markerControls, '===Controls')
      // console.log(markerControls.object3d, markerControls.object3d.updateProjectionMatrix)
      markerControls.object3d.updateProjectionMatrix();
      camera.projectionMatrix.copy(arToolkitContext.getProjectionMatrix());
      const geometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
      const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
      const cube = new THREE.Mesh(geometry, material);
      const points = screenToWorldVector(
        e.touches[0].clientX,
        e.touches[0].clientY
      );
      // const geometry2 = new THREE.BoxGeometry(0.1, 0.1, 0.1);
      // const material2 = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
      // const cube2 = new THREE.Mesh(geometry2, material2);
      // // console.log(points)
      // cube.position.set(points.x, 1, points.z);
      cube.position.set(points.x, points.y, points.z);
      scene.add(cube);
      console.log(points)
      // scene.add(cube2)
      // const matrix = new THREE.Matrix4().makeRotationFromQuaternion(
      //   new THREE.Quaternion().setFromUnitVectors(
      //     new THREE.Vector3(0, 0, 1), // 初始向量
      //     new THREE.Vector3(0, 1, 0)
      //   )
      // );
      // console.log(matrix)
      // const p = new THREE.Vector3( e.touches[0].clientX, e.touches[0].clientY, 0).applyMatrix4(matrix);
      // console.log(p, camera)
    });

    function screenToWorldVector(evX, evY, p, w) {
      const width = window.innerWidth;
      const height = window.innerHeight;
      // console.log(camera)
      const x = evX;
      const y = evY;
      const x1 = (x / width) * 2 - 1;
      const y1 = -(y / height) * 2 + 1;
      const stdVector = new THREE.Vector3(x1, y1, 0.5);
      const worldVector = stdVector.unproject(camera);
      return worldVector;
    }

    // array of functions for the rendering loop
    var onRenderFcts = [];

    // init scene and camera
    var scene = new THREE.Scene();

    // Create a camera
    // var camera = new THREE.Camera();
    const camera = new THREE.PerspectiveCamera(60, 1, 1, 1000);
    scene.add(camera);

    var arToolkitSource = new THREEx.ArToolkitSource({
      sourceType: "webcam",
    });

    arToolkitSource.init(function onReady() {
      setTimeout(() => {
        onResize();
      }, 2000);
    });

    // handle resize
    window.addEventListener("resize", function () {
      onResize();
    });

    function onResize() {
      arToolkitSource.onResizeElement();
      arToolkitSource.copyElementSizeTo(renderer.domElement);
      if (arToolkitContext.arController !== null) {
        arToolkitSource.copyElementSizeTo(arToolkitContext.arController.canvas);
      }
    }

    const div = document.createElement("div");
    div.style.marginTop = "60px";
    const div2 = document.createElement("div");
    div2.style.marginTop = "20px";
    document.body.appendChild(div);
    document.body.appendChild(div2);

    // create atToolkitContext
    var arToolkitContext = new THREEx.ArToolkitContext({
      cameraParametersUrl: THREEx.ArToolkitContext.baseURL + "camera_para.dat",
      detectionMode: "mono",
    });
    // initialize it
    arToolkitContext.init(function onCompleted() {
      // copy projection matrix to camera
      camera.projectionMatrix.copy(arToolkitContext.getProjectionMatrix());
    });

    // update artoolkit on every frame
    onRenderFcts.push(function () {
      if (arToolkitSource.ready === false) return;
      arToolkitContext.update(arToolkitSource.domElement, div, div2);
      // update scene.visible if the marker is seen
      scene.visible = camera.visible;
    });

    // init controls for camera
    var markerControls = new THREEx.ArMarkerControls(
      arToolkitContext,
      camera,
      {
        type: "pattern",
        patternUrl: THREEx.ArToolkitContext.baseURL + "jgw.patt",
        changeMatrixMode: "cameraTransformMatrix",
      },
      (m) => {
        // matrixWorld.copy(m.matrixWorld)
        // console.log(m, camera)
      }
    );
    // as we do changeMatrixMode: 'cameraTransformMatrix', start with invisible scene
    scene.visible = false;

    // add a torus knot
    var geometry = new THREE.CubeGeometry(1, 1, 1);
    var material = new THREE.MeshNormalMaterial({
      transparent: true,
      opacity: 0.5,
      side: THREE.DoubleSide,
    });
    var mesh = new THREE.Mesh(geometry, material);
    mesh.position.y = geometry.parameters.height / 2;
    scene.add(mesh);

    var geometry = new THREE.TorusKnotGeometry(0.3, 0.1, 64, 16);
    var material = new THREE.MeshNormalMaterial();
    var mesh = new THREE.Mesh(geometry, material);
    mesh.position.y = 0.5;
    scene.add(mesh);

    // 辅助线
    const axesHelper = new THREE.AxesHelper(1);
    scene.add(axesHelper);

    onRenderFcts.push(function (delta) {
      mesh.rotation.x += Math.PI * delta;
    });

    // render the scene
    onRenderFcts.push(function () {
      renderer.render(scene, camera);
    });

    // run the rendering loop
    var lastTimeMsec = null;
    requestAnimationFrame(function animate(nowMsec) {
      // keep looping
      requestAnimationFrame(animate);
      // measure time
      lastTimeMsec = lastTimeMsec || nowMsec - 1000 / 60;
      var deltaMsec = Math.min(200, nowMsec - lastTimeMsec);
      lastTimeMsec = nowMsec;
      // call each update function

      onRenderFcts.forEach(function (onRenderFct) {
        // console.log(onRenderFcts)
        onRenderFct(deltaMsec / 1000, nowMsec / 1000);
      });
    });
  </script>
</body>
